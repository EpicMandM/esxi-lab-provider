version: 3
dotenv: ['.env']

vars:
  BINARY_NAME: esxi-lab-scheduler
  REMOTE_PATH: /opt/esxi-lab
  SERVICE_NAME: esxi-lab-scheduler
  USER: '{{.DEPLOY_USER | default "zhukov"}}'
  HOST: '{{.DEPLOY_HOST | default "172.17.17.8"}}'
  PORT: '{{.DEPLOY_PORT | default "22"}}'
  SSH_KEY: '{{.HOME}}/.ssh/id_rsa_esxi_lab'
  SSH: ssh -i {{.SSH_KEY}} -o StrictHostKeyChecking=no -p {{.PORT}} {{.USER}}@{{.HOST}}
  SCP: scp -i {{.SSH_KEY}} -o StrictHostKeyChecking=no -P {{.PORT}}

tasks:
  default:
    desc: Build the scheduler binary
    cmds:
      - task: build

  build:
    desc: Build the scheduler binary
    dir: api
    cmds:
      - CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o ../{{.BINARY_NAME}} ./cmd/server/main.go
    sources:
      - api/**/*.go
    generates:
      - "{{.BINARY_NAME}}"

  ssh-keygen:
    desc: Generate SSH key and upload to remote server for passwordless access
    cmds:
      - |
        if [ ! -f {{.SSH_KEY}} ]; then
          echo "Generating new SSH key..."
          ssh-keygen -t rsa -b 4096 -f {{.SSH_KEY}} -N "" -C "esxi-lab-deployment"
        else
          echo "SSH key already exists at {{.SSH_KEY}}"
        fi
      - ssh-copy-id -i {{.SSH_KEY}}.pub -p {{.PORT}} {{.USER}}@{{.HOST}}

  setup-sudo:
    desc: Configure passwordless sudo for deployment user
    cmds:
      - |
        {{.SSH}} -t "echo '{{.USER}} ALL=(ALL) NOPASSWD: ALL' | sudo tee /etc/sudoers.d/{{.USER}} > /dev/null && sudo chmod 0440 /etc/sudoers.d/{{.USER}}"

  setup-logging:
    desc: Configure journald to retain logs for 7 days
    cmds:
      - |
        {{.SSH}} "sudo mkdir -p /etc/systemd/journald.conf.d && sudo tee /etc/systemd/journald.conf.d/retention.conf > /dev/null <<EOF
        [Journal]
        Storage=persistent
        MaxRetentionSec=7d
        SystemMaxUse=500M
        EOF"
      - '{{.SSH}} "sudo systemctl restart systemd-journald"'

  deploy:
    desc: Deploy scheduler to remote server via SSH
    deps: [build]
    cmds:
      - echo "Deploying to {{.USER}}@{{.HOST}}:{{.PORT}}"
      - '{{.SSH}} "sudo mkdir -p {{.REMOTE_PATH}} && sudo chown {{.USER}}:{{.USER}} {{.REMOTE_PATH}}"'
      - '{{.SCP}} {{.BINARY_NAME}} {{.USER}}@{{.HOST}}:{{.REMOTE_PATH}}/{{.BINARY_NAME}}'
      - '{{.SCP}} .env {{.USER}}@{{.HOST}}:{{.REMOTE_PATH}}/.env'
      - '{{.SCP}} api/data/user_config.toml {{.USER}}@{{.HOST}}:{{.REMOTE_PATH}}/user_config.toml'
      - '{{.SCP}} infra/terraform/service-account.json {{.USER}}@{{.HOST}}:{{.REMOTE_PATH}}/service-account.json'
      - |
        {{.SSH}} "sudo tee /etc/systemd/system/{{.SERVICE_NAME}}.service > /dev/null <<EOF
        [Unit]
        Description=ESXi Lab Scheduler
        After=network.target

        [Service]
        Type=oneshot
        User={{.USER}}
        WorkingDirectory={{.REMOTE_PATH}}
        Environment=CONFIG_PATH={{.REMOTE_PATH}}/user_config.toml
        Environment=SERVICE_ACCOUNT_PATH={{.REMOTE_PATH}}/service-account.json
        EnvironmentFile={{.REMOTE_PATH}}/.env
        ExecStart={{.REMOTE_PATH}}/{{.BINARY_NAME}}
        StandardOutput=journal
        StandardError=journal
        SyslogIdentifier={{.SERVICE_NAME}}

        [Install]
        WantedBy=multi-user.target
        EOF"
      - |
        {{.SSH}} "sudo tee /etc/systemd/system/{{.SERVICE_NAME}}.timer > /dev/null <<EOF
        [Unit]
        Description=ESXi Lab Scheduler Timer (runs at the start of every hour)

        [Timer]
        OnCalendar=*:00:00
        AccuracySec=1s
        Persistent=false

        [Install]
        WantedBy=timers.target
        EOF"
      - '{{.SSH}} "sudo chmod +x {{.REMOTE_PATH}}/{{.BINARY_NAME}}"'
      - '{{.SSH}} "sudo systemctl daemon-reload"'
      - '{{.SSH}} "sudo systemctl enable {{.SERVICE_NAME}}.timer"'
      - '{{.SSH}} "sudo systemctl restart {{.SERVICE_NAME}}.timer"'

  status:
    desc: Check scheduler status on remote server
    cmds:
      - '{{.SSH}} "sudo systemctl status {{.SERVICE_NAME}}.timer"'
      - '{{.SSH}} "sudo systemctl list-timers {{.SERVICE_NAME}}.timer"'

  logs:
    desc: View scheduler logs on remote server
    vars:
      LINES: '{{.LINES | default "50"}}'
    cmds:
      - '{{.SSH}} "sudo journalctl -u {{.SERVICE_NAME}}.service -n {{.LINES}} --no-pager"'

  stop:
    desc: Stop and disable scheduler on remote server
    cmds:
      - '{{.SSH}} "sudo systemctl stop {{.SERVICE_NAME}}.timer"'
      - '{{.SSH}} "sudo systemctl disable {{.SERVICE_NAME}}.timer"'

  clean:
    desc: Remove deployment files from remote server
    cmds:
      - '{{.SSH}} "sudo systemctl stop {{.SERVICE_NAME}}.timer"'
      - '{{.SSH}} "sudo systemctl disable {{.SERVICE_NAME}}.timer"'
      - '{{.SSH}} "sudo rm -f /etc/systemd/system/{{.SERVICE_NAME}}.service"'
      - '{{.SSH}} "sudo rm -f /etc/systemd/system/{{.SERVICE_NAME}}.timer"'
      - '{{.SSH}} "sudo rm -rf {{.REMOTE_PATH}}"'
      - '{{.SSH}} "sudo systemctl daemon-reload"'

  test-run:
    desc: Trigger a single scheduler run on remote server
    cmds:
      - '{{.SSH}} "sudo systemctl start {{.SERVICE_NAME}}.service"'
      - '{{.SSH}} "sudo journalctl -u {{.SERVICE_NAME}}.service -n 50"'

  test:
    desc: Run all unit tests
    dir: api
    cmds:
      - go test ./... -count=1

  test:verbose:
    desc: Run all unit tests with verbose output
    dir: api
    cmds:
      - go test ./... -v -count=1

  test:coverage:
    desc: Run tests with coverage report and enforce thresholds
    dir: api
    cmds:
      - go test ./... -coverprofile=coverage.out -count=1
      - go tool cover -func=coverage.out
      - |
        echo ""
        echo "=== Coverage Gate ==="
        FAIL=0
        for pkg in internal/config internal/logger internal/orchestrator; do
          pct=$(go tool cover -func=coverage.out \
            | awk -v p="github.com/EpicMandM/esxi-lab-provider/api/${pkg}" '$1 ~ p && /total:/ {gsub(/%/,"",$NF); print $NF}')
          if [ -z "$pct" ]; then
            pct=$(go test -cover ./${pkg}/ 2>&1 \
              | awk -F'[[:space:]]+|%' '/coverage:/{for(i=1;i<=NF;i++) if($i+0==$i && $i>0){print $i; exit}}')
          fi
          if awk "BEGIN{exit(!($pct+0 < 100.0))}"; then
            echo "FAIL: ${pkg} coverage is ${pct}% (required: 100%)"
            FAIL=1
          else
            echo "PASS: ${pkg} coverage is ${pct}%"
          fi
        done
        if [ "$FAIL" = "1" ]; then
          echo ""
          echo "Coverage gate FAILED. Fix failing packages before committing."
          exit 1
        fi
        echo ""
        echo "Coverage gate PASSED."
      - rm -f coverage.out
